var documenterSearchIndex = {"docs":
[{"location":"api/#API/Reference-1","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/#","page":"API/Reference","title":"API/Reference","text":"For now, here is a dump of all documented functions and types.","category":"page"},{"location":"api/#Index-1","page":"API/Reference","title":"Index","text":"","category":"section"},{"location":"api/#","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#API/Reference-2","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/#","page":"API/Reference","title":"API/Reference","text":"Modules = [HCIToolbox]","category":"page"},{"location":"api/#HCIToolbox.combine-Union{Tuple{AbstractArray{T,3}}, Tuple{T}} where T","page":"API/Reference","title":"HCIToolbox.combine","text":"combine(cube, [angles]; method=median)\n\nCombine all the frames of a cube using method. If angles are provided, will use derotate! before combining.\n\nNote that with angles this is slightly slower than doing combine(derotate!(cube, angles)), if you can overwrite the input.\n\nExamples\n\njulia> X = ones(2, 3, 3)\n2×3×3 Array{Float64,3}:\n[:, :, 1] =\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n[:, :, 2] =\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\n[:, :, 3] =\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> combine(X)\n3×3 Array{Float64,2}:\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n 1.0  1.0  1.0\n\njulia> combine(X, [0, 90])\n1×3×3 Array{Float64,3}:\n[:, :, 1] =\n 1.0  1.0  1.0\n\n[:, :, 2] =\n NaN  1.0  NaN\n\n[:, :, 3] =\n 1.0  1.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.derotate!-Union{Tuple{T}, Tuple{AbstractArray{T,3},AbstractArray{T,1} where T}} where T<:AbstractFloat","page":"API/Reference","title":"HCIToolbox.derotate!","text":"derotate!(cube, angles)\n\nIn-place version of derotate\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.derotate-Union{Tuple{T}, Tuple{AbstractArray{T,3},AbstractArray{T,1} where T}} where T","page":"API/Reference","title":"HCIToolbox.derotate","text":"derotate(cube, angles)\n\nRotates an array using the given angles in degrees.\n\nThis will rotate frame i counter-clockwise by the amount deg2rad(angles[i]).\n\nSee Also\n\nderotate!, rotate, rotate!\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.expand-Tuple{AbstractArray{T,2} where T}","page":"API/Reference","title":"HCIToolbox.expand","text":"expand(matrix)\n\nGiven a matrix of size (n, z), returns a cube of size (n, x, x) where x=√z.\n\nWill throw an error if z is not a perfect square.\n\nExamples\n\njulia> X = ones(3, 4)\n3×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\njulia> expand(X)\n3×2×2 Array{Float64,3}:\n[:, :, 1] =\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n\n[:, :, 2] =\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n\nSee Also\n\nflatten\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.flatten-Union{Tuple{AbstractArray{T,3}}, Tuple{T}} where T","page":"API/Reference","title":"HCIToolbox.flatten","text":"flatten(cube)\n\nGiven a cube of size (n, x, y) returns a matrix with size (n, x * y) where each row is a flattened image from the cube.\n\nExamples\n\njulia> X = ones(3, 2, 2)\n3×2×2 Array{Float64,3}:\n[:, :, 1] =\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n\n[:, :, 2] =\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n\njulia> flatten(X)\n3×4 Array{Float64,2}:\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n 1.0  1.0  1.0  1.0\n\nSee Also\n\nexpand\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.mask_annulus!-Tuple{AbstractArray{T,2} where T,Any,Any}","page":"API/Reference","title":"HCIToolbox.mask_annulus!","text":"mask_annulus!(::AbstractMatrix, npix_in, npix_out; fill=NaN)\n\nIn-place version of mask_annulus\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.mask_annulus-Tuple{AbstractArray{T,2} where T,Any,Any}","page":"API/Reference","title":"HCIToolbox.mask_annulus","text":"mask_annulus(::AbstractMatrix, npix_in, npix_out; fill=0)\n\nMask an annular region of an image with inner-radius npix_in, outer-radius npix_out with value fill. Note that the input type must be compatible with the fill value's type.\n\nSee Also\n\nmask_annulus!\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.mask_circle!-Tuple{AbstractArray{T,2} where T,Any}","page":"API/Reference","title":"HCIToolbox.mask_circle!","text":"mask_circle!(::AbstractMatrix, npix; fill=0)\n\nIn-place version of mask_circle\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.mask_circle-Tuple{AbstractArray{T,2} where T,Any}","page":"API/Reference","title":"HCIToolbox.mask_circle","text":"mask_circle(::AbstractMatrix, npix; fill=0)\n\nMask the inner-circle of an image with radius npix with value fill. Note that the input type must be compatible with the fill value's type.\n\nSee Also\n\nmask_circle!\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.rotate!-Union{Tuple{T}, Tuple{AbstractArray{T,3},AbstractArray{T,1} where T}} where T<:AbstractFloat","page":"API/Reference","title":"HCIToolbox.rotate!","text":"rotate!(cube, angles)\n\nIn-place version of derotate\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.rotate-Union{Tuple{T}, Tuple{AbstractArray{T,3},AbstractArray{T,1} where T}} where T","page":"API/Reference","title":"HCIToolbox.rotate","text":"rotate(cube, angles)\n\nRotates an array using the given angles in degrees.\n\nThis will rotate frame i clockwise by the amount deg2rad(angles[i]).\n\nSee Also\n\nrotate!, derotate, derotate!\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.get_annulus_segments-NTuple{4,Any}","page":"API/Reference","title":"HCIToolbox.get_annulus_segments","text":"get_annulus_segments(data, inner_radius, width, [nsegments]; theta_init=0, scale_factor=1, mode=:index)\n\nReturns indices or values in segments of a centered annulus.\n\nModes\n\n:mask - returns a positive boolean mask for indexing\n:value - returns the data values indexed with the boolean mask\n:apply - returns the input data weighted by the boolean mask\n\n\n\n\n\n","category":"method"},{"location":"api/#","page":"API/Reference","title":"API/Reference","text":"Modules = [HCIToolbox.Metrics]","category":"page"},{"location":"api/#HCIToolbox.Metrics.significance-Tuple{AbstractArray{T,2} where T,Any}","page":"API/Reference","title":"HCIToolbox.Metrics.significance","text":"significance(snr::AbstractMatrix, fwhm)\n\nCalculates the Gaussian significance from the signal-to-noise ratio (SNR, S/N).\n\nThe Gaussian signifiance is calculated from converting the SNR confidence limit from a student t distribution to a Gaussian via\n\ntextsig(textSNR) = Phi^-1leftint_0^textSNRt_nu(x)dxright\n\nwhere the degrees of freedom nu is given as 2pi r  Gamma - 2 where r is the radial distance of each pixel from the center of the frame.\n\nSee Also\n\nsnrmap\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.Metrics.snr-Tuple{AbstractArray{T,2} where T,Any,Any}","page":"API/Reference","title":"HCIToolbox.Metrics.snr","text":"snr(data, position, fwhm)\n\nCalculate the signal to noise ratio (SNR, S/N) for a test point at position using apertures of diameter fwhm in a residual frame.\n\nUses the method of Mawet et al. 2014 which includes penalties for small sample statistics. These are encoded by using a student's t-test for calculating the SNR.\n\nnote: Note\nSNR is not equivalent to significance, use significance instead\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.Metrics.snr_approx-Tuple{Any,Any,Any}","page":"API/Reference","title":"HCIToolbox.Metrics.snr_approx","text":"snr_approx(data, position, fwhm)\n\nCalculates an approximate signal to noise ratio (SNR, S/N) for a test point at position using apertures of diameter fwhm in a residual frame.\n\nApplies the small sample statistics penalty the same as snr. Data is assumed to have been filtered using a 2D top-hat kernel already (automatically done if called via snrmap)\n\nnote: Note\nSNR is not equivalent to significance, use significance instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.Metrics.snrmap-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any}} where T","page":"API/Reference","title":"HCIToolbox.Metrics.snrmap","text":"snrmap(data, fwhm; snr_func=snr)\n\nParallel implementation of signal-to-noise ratio (SNR, S/N) applied to each pixel in the input image.\n\nSNR Functions\n\nsnr - Exact SNR using student t statistics (small samples penalty)\nsnr_approx! - Approximate SNR using student t statistics (small samples penalty). Using this function will automatically filter data with a 2D top-hat kernel of diameter fwhm. You can use the non-mutating snr_approx, but the data is already copied after filtering so the mutating version will be more performant.\n\ntip: Tip\nThis code is automatically multi-threaded, so be sure to set JULIA_NUM_THREADS before loading your runtime to take advantage of it!\n\n\n\n\n\n","category":"method"},{"location":"api/#HCIToolbox.Metrics.snr_approx!-Tuple{AbstractArray{T,2} where T,Any,Any}","page":"API/Reference","title":"HCIToolbox.Metrics.snr_approx!","text":"snr_approx!(data, position, fwhm)\n\nIn-place version of snr_approx which modifies data.\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = HCIToolbox","category":"page"},{"location":"#HCIToolbox.jl-1","page":"Home","title":"HCIToolbox.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: Coverage) (Image: License)","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"From Julia enter Pkg mode","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia>]\n\n(1.3) pkg> add HCIToolbox","category":"page"},{"location":"#License-1","page":"Home","title":"License","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This work is distributed under the MIT \"expat\" license. See LICENSE for more information.","category":"page"}]
}
