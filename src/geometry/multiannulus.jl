
struct MultiAnnulusView{T,N,M<:AbstractArray{T,N},RT,IT} <: AbstractArray{T,N}
    parent::M
    radii::RT
    width::Float64
    indices::IT
    fill::T
end


"""
    MultiAnnulusView(cube::AbstractArray{T,3} width, radii; fill=0)

Create multiple annuli at each radius in `radii` with width `width`. Values that fall outside of these regions will be replaced with `fill`. This does not copy any data, it is merely a view into the data.
"""
function MultiAnnulusView(parent::AbstractArray{T,3}, width, radii; fill=zero(T)) where T
    time_axis = axes(parent, 3)
    space_indices = CartesianIndices((axes(parent, 1), axes(parent, 2)))
    space_axes = map(radii) do r
        inner = r - width / 2
        outer = r + width / 2
        filter(idx -> inside_annulus(inner, outer, center(parent)[1:2], idx), space_indices)
    end
    indices = [(space_axis, time_axis) for space_axis in space_axes]
    return MultiAnnulusView(parent, radii, Float64(width), indices, convert(T, fill))
end

"""
    MultiAnnulusView(cube::AbstractArray{T,3}, width;
                     inner=0, outer=first(size(parent))/2 + 0.5,
                     fill=0)

Create multiple annuli between `inner` and `outer` with `width` spacing. Values that fall outside of these regions will be replaced with `fill`. This does not copy any data, it is merely a view into the data.
"""
function MultiAnnulusView(parent::AbstractArray{T,3}, width; inner=0, outer=(first(size(parent)) + 1) / 2, fill=zero(T)) where T
    first_r = inner + width/2
    if isfinite(outer)
        final_r = outer - width/2
    else
        max_length = (first(size(parent)) + 1) / 2
        max_r = sqrt(2 * max_length^2)
        final_r = max_r + 1 / sqrt(2)
    end
    radii = range(first_r, final_r, step=width)
    return MultiAnnulusView(parent, width, radii; fill=fill)
end

Base.parent(view::MultiAnnulusView) = view.parent
Base.size(view::MultiAnnulusView) = size(parent(view))
Base.copy(view::MultiAnnulusView) = MultiAnnulusView(copy(parent(view)), view.radii, view.width, view.indices, view.fill)

@propagate_inbounds function Base.getindex(view::MultiAnnulusView{T,N}, idx::Vararg{<:Integer,N}) where {T,N}
    @boundscheck checkbounds(parent(view), idx...)
    inside = any(r -> inside_annulus(r-view.width/2, r+view.width/2, center(parent(view))[1:2], idx...), view.radii)
    ifelse(inside, convert(T, parent(view)[idx...]), view.fill)
end

@propagate_inbounds function Base.setindex!(view::MultiAnnulusView{T,N}, val, idx::Vararg{<:Integer,N}) where {T,N}
    @boundscheck checkbounds(parent(view), idx...)
    inside = any(r -> inside_annulus(r - view.width/2, r + view.width/2, center(parent(view))[1:2], idx...), view.radii)
    if inside
        parent(view)[idx...] = val
    else
        view.fill
    end
end

"""
    (::MultiAnnulusView)(idx, asview=false)

Return the `idx`th annulus as a matrix. This is equivalent to unrolling the frame and filtering out pixels outside of the `idx`th annulus. If `asview` is true, the returned values will be a view of the parent array instead of a copy.

# Examples

```jldoctest
julia> ann = MultiAnnulusView(ones(101, 101, 10), 5; inner=5, outer=30);

julia> X = ann(1);

julia> size(X)
(10, 248)

julia> X2 = ann(2);

julia> size(X2)
(10, 404)
```

# See also
[`eachannulus`](@ref)
"""
@propagate_inbounds function (view::MultiAnnulusView)(idx::Int, asview=false)
    @boundscheck checkbounds(view.indices, idx)
    idxs = view.indices[idx]
    if asview
        @view parent(view)[idxs...]
    else
        parent(view)[idxs...]
    end
end

"""
    eachannulus(::MultiAnnulusView, asview=false)

Create a generator for each annulus in the view. If `asview` is true, the annuli will be returned as a view into the parent array instead of a copy.

# Examples
```jldoctest
julia> ann = MultiAnnulusView(ones(101, 101, 10), 5; inner=5, outer=30);

julia> [size(X) for X in eachannulus(ann)]
5-element Array{Tuple{Int64,Int64},1}:
 (10, 248)
 (10, 404)
 (10, 560)
 (10, 716)
 (10, 880)
```
"""
eachannulus(view::MultiAnnulusView, asview=false) = (view(i, asview) for i in 1:length(view.indices))


"""
    copyto!(::MultiAnnulusView, idx, mat)
    copyto!(::MultiAnnulusView, mats...)

Copy the pixels from `mat` into the pixels in the `idx`th annulus. `mat` should have the same size as the matrices generated by [`MultiAnnulusView`](@ref). If multiple matrices are supplied, it is assumed each one corresponds to each annulus in the view.

# Examples

Update a single annulus-

```jldoctest
julia> ann = MultiAnnulusView(ones(101, 101, 10), 5; inner=5, outer=30);

julia> X = ann(1);

julia> new_ann = copyto!(ann, 1, -X);

julia> new_ann(1) ≈ -X
true
```

update each annulus-

```jldoctest
julia> ann = MultiAnnulusView(ones(101, 101, 10), 5; inner=5, outer=30);

julia> Xs = [-X for X in eachannulus(ann)];

julia> new_ann = copyto!(copy(ann), Xs);

julia> new_ann ≈ -ann
true
```
"""
function Base.copyto!(view::MultiAnnulusView, mats::Vararg{<:AbstractMatrix})
    if length(mats) != length(view.indices)
        error("Number of matrices does not match number of annuli")
    end
    inverse!(view, view.parent, mats...)
    return view
end

Base.copyto!(view::MultiAnnulusView, mats::AbstractVector{<:AbstractMatrix}) = copyto!(view, mats...)

function Base.copyto!(view::MultiAnnulusView, idx::Int, mat::AbstractMatrix)
    inverse!(view, view.parent, idx, mat)
    return view
end

"""
    inverse!(::MultiAnnulusView, out, idx, mat)
    inverse!(::MultiAnnulusView, out, mats...)

In-place version of [`inverse`](@ref) that fills `out` with annuli defined by the geometry of the view.
"""
function inverse!(view::MultiAnnulusView, out, mats::Vararg{<:AbstractMatrix})
    if length(mats) != length(view.indices)
        error("Number of matrices does not match number of annuli")
    end
    for (idxs, mat) in zip(view.indices, mats)
        out[idxs...] = mat
    end
    return out
end

function inverse!(view::MultiAnnulusView, out, idx::Int, mat::AbstractMatrix)
    idxs = view.indices[idx]
    out[idxs...] = mat
    return out
end

inverse!(view::MultiAnnulusView, out, mats) = inverse!(view, out, mats...)



"""
    inverse(::MultiAnnulusView, idx, mat)
    inverse(::MultiAnnulusView, mats...)

Generate a cube similar to the view using the given pixel matrices. The pixels from `mat` will be put into the location of the `idx`th annulus. `mat` should have the same size as the output matrices generated by [`MultiAnnulusView`](@ref). If multiple matrices are supplied, it is assumed each one corresponds to each annulus in the view.



# Examples

Expand a single annulus-

```jldoctest ann
julia> ann = MultiAnnulusView(ones(101, 101, 10), 5; inner=5, outer=30);

julia> X = ann(1);

julia> out = inverse(ann, 1, -X);

julia> sum(out) == -sum(X)
true
```

expand many annuli-

```jldoctest ann
julia> Xs = [-X for X in eachannulus(ann)];

julia> out = inverse(ann, Xs);

julia> out ≈ -ann
true
```
"""
function inverse(view::MultiAnnulusView, args...)
    out = fill!(similar(parent(view)), view.fill)
    inverse!(view, out, args...)
end
inverse(view::MultiAnnulusView, mats) = inverse(view, mats...)
